group DirectRuntimeSource;

// Class
class(name, base, members) ::= <<
public class <name> extends <base> {
    <members; separator="\n">
}
>>


// Method
method(name, type, mods, args, block) ::= <<
<if(mods)><mods; separator=" "><endif> <type> <name>(<args; separator=", ">) <block>
>>


// Read from source image
imageread(var, pixel, band) ::= <<
readFromImage("<var>", <if(xy)><xy><else>_x, _y<endif>, <if(band)><band><else>0<endif>)
>>

pixel(x, y) ::= <<
<x>, <y>
>>


// Write to destination image
imagewrite(var, expr) ::= <<
writeToImage("<var>", _x, _y, 0, <expr>)
>>


// Block
block(stmts) ::= <<
{
    <stmts; separator="\n">
}
>>


// Delimited statement
delimstmt(stmt) ::= "<stmt>;"


// Loop: while
while(cond, stmt) ::= <<
while (true) {
    if (JiffleFunctions.sign(<cond>) != 1) break;
    <stmt>
}
>>


// Loop: until
until(cond, stmt) ::= <<
while (true) {
    if (JiffleFunctions.sign(<cond>) == 1) break;
    <stmt>
}
>>


// WRITE ME
// Loop: foreach with list
foreachlist(var, list, stmt) ::= <<
>>


// WRITE ME
// Loop: foreach with sequence
foreachseq(var, list, stmt) ::= <<
>>


// Loop exit - breakif
breakif(cond) ::= <<
if (JiffleFunctions.sign(<cond>) == 1) break;
>>


////////////////////////////////////////////////////////////
// If-calls
//
// These are treated separately from general functions to 
// ensure lazy evaluation of the alternatives


// This template is called from the grammar
ifcall(args) ::= <<
<({if<length(args)>})(args)>
>>


// These helper templates are called by ifcall
if1(cond) ::= <<
(_stk.push(_FN.sign(<first(args)>)) == null ? Double.NaN :
    _stk.peek() != 0 ? 1.0 : 0.0)
>>

if2(args) ::= <<
(_stk.push(_FN.sign(<first(args)>)) == null ? Double.NaN : 
    _stk.peek() != 0 ? <last(args)> : 0.0)
>>

if3(args) ::= <<
(_stk.push(_FN.sign(<first(args)>)) == null ? Double.NaN : 
    _stk.peek() != 0 ? <first(rest(args))> : <last(args)>)
>>

if4(args) ::= <<
(_stk.push(_FN.sign(<first(args)>)) == null ? Double.NaN : 
    _stk.peek() == 1 ? <first(rest(args))> : 
        _stk.peek() == 0 ? <first(rest(rest(args)))> : <last(args)>)
>>


////////////////////////////////////////////////////////////
// General function call

call(name, args) ::= <<
<name>(<args; separator=", ">)
>>


////////////////////////////////////////////////////////////
// Binary expressions


// general binary expression
binaryexpr(lhs, op, rhs) ::= <<
<lhs> <op> <rhs>
>>

pow(x, y) ::= <<
Math.pow(<x>, <y>)
>>


////////////////////////////////////////////////////////////
// Parenthesised expression

par(expr) ::= "(<expr>)"



////////////////////////////////////////////////////////////
// Var declaration

vardecl(name, type, mods, init) ::= <<
<if(mods)><mods; separator=" "><endif> <type> <name><if(init)> = <init><endif>
>>


////////////////////////////////////////////////////////////
// Field declaration (image scope variable or option 
// variable)

field(name, type, mods, init) ::= "<vardecl(...)>;"


////////////////////////////////////////////////////////////
// Operator - required to deal with ops involving '<' and '>'

operator(op) ::= "<op>"

